#!/usr/bin/env python

"""
PARAMETERS:
    /steering/k (double): proportional steering gain to align car to have center line on the left
    /steering/stop_acc_min (int): number of consecutive times a horizontal stop marker has to be identified to be considered
    /steering/after_stop_delay (int): number of loops that the car is still after braking
    /steering/target_low (int): lower target threshold for x-coordinate of the upper end of the center line
    /steering/target_high (int): upper target threshold for x-coordinate of the upper end of the center line
    /steering/intersection_y_threshold (int): turn right when the intersection perpendicular center line is at image coord y > this value

PUBLISHES:
    prius (prius_msgs/Control): throttle, braking, steering and gear to control Prius

SUBSCRIBES:
    my_lanes/vals (std_msgs/Int32MultiArray): key points of the lanes and stop markers detected
    is_clear/front_sonar/all (std_msgs/Byte): if 0 is clear, else an obstacle is detected (4 lsb describe where obstacle is detected, from left to right sonar)
    is_clear/front_camera/all (std_msgs/Byte): if 0 is clear, else an obstacle is detected (5th bit is obstacle from camera)
    base_pose_ground_truth (nav_msgs/Odometry): true position of the Prius with respect to the origin of the Gazebo world


SERVICES:
    enable_driving (self_driving/enable_driving): 0 holds the car in brake, 1 drives autonomously with continuous right turns
    destination (self_driving/destination): input x and y coordinates (in Gazebo world frame) of the destination to have the car drive there
    destination_landmark (self_driving/destination_landmark): input code of the landmark towards which the car should drive (see documentation/comments)

"""

import rospy
import numpy as np
from prius_msgs.msg import Control
from nav_msgs.msg import Odometry
from self_driving.srv import enable_driving, destination, destination_landmark
from std_msgs.msg import Int32MultiArray, Byte


def navigation(data):
    global x_prev, y_prev, x_goal, y_goal, margin, eps, turn_right, is_arrived, correct_intersection_trigger, cond1, cond2
    x = data.pose.pose.position.x
    y = data.pose.pose.position.y
    if x_goal is not None and y_goal is not None:
        x_dst = x - x_goal
        y_dst = y - y_goal
        x_dst_prev = x_prev - x_goal
        y_dst_prev = y_prev - y_goal
        x_dot = x - x_prev
        y_dot = y - y_prev
        
        if not in_intersection:
            cond1 = abs(y_dst_prev) - abs(y_dst) > eps  # getting closer in x
            cond2 = abs(x_dst_prev) - abs(x_dst) > eps  # getting closer in y

        if not is_braking:
            if ((abs(x_dst_prev) > margin and abs(x_dst) < margin) or (abs(y_dst_prev) > margin and abs(y_dst) < margin)) and not (abs(x_dst) < margin and abs(y_dst) < margin):  # got in margin zone
                correct_intersection_trigger = True
            
            if abs(x_dst) > margin and abs(y_dst) > margin:
                correct_intersection_trigger = False

        msg = Byte()
        # TODO does not work
        if (cond1 or cond2) and not correct_intersection_trigger:
            turn_right = False  # do not turn right (go straight)
        else:
            turn_right = True  # turn right
        if -margin < x_dst < margin and -margin < y_dst < margin and (not cond1) and (not cond2):
            is_arrived = True
        #print(str(cond1) + " " + str(cond2) + " " + str(correct_intersection_trigger))
    x_prev = x
    y_prev = y

def is_clear_sonar_callback(data):
    global is_clear_all
    is_clear_all = (is_clear_all & 0b10000) | data.data 

def is_clear_camera_callback(data):
    global is_clear_all
    if data.data:
        is_clear_all = is_clear_all | 0b10000
    else:
        is_clear_all = is_clear_all & 0b01111

def service_callback(req):
    # change global variable driving_ctrl to enable/disable self driving
    global driving_ctrl
    driving_ctrl = req.ctrl
    return []

def service_destination_callback(req):
    global driving_ctrl, is_arrived, x_goal, y_goal
    driving_ctrl = 1
    is_arrived = 0
    x_goal = req.x
    y_goal = req.y
    return []

def service_landmark_callback(req):
    global driving_ctrl, is_arrived, x_goal, y_goal
    driving_ctrl = 1
    is_arrived = 0
    if req.landmark == 1:  # house_2
        x_goal = 24
        y_goal = 9
    elif req.landmark == 2:  # law office
        x_goal = 12
        y_goal = -18
    elif req.landmark == 3:  # construction cone
        x_goal = -12
        y_goal = 0
    elif req.landmark == 4:  # school
        x_goal = -24
        y_goal = -9
    elif req.landmark == 5:  # suv
        x_goal = 0
        y_goal = 9
    else:  # invalid landmark code
        driving_ctrl = 0
        is_arrived = 1
    return []

def callback(data):
    # callback to execute when receiving lane values
    global throttle, brake, steer, gear, stop_acc, after_stop_count, delay_current, iteration, in_intersection, started_turning, center_line_acc, is_braking, correct_intersection_trigger
    pts_array = []  # array of points
    types = []  # array of types
    array = data.data  # array of [point, type, point, type, point, type...]
    intersection_center = None

    gear = 2  # put Prius in drive
    brake = 0
    steer = 0
    if iteration < 4:  # initial throttle to start car
        throttle = 0.01
    else:
        throttle = 0
        if not iteration % 4:  # brake every x iterations to not gain excessive speed
            brake = 0.1
    is_braking = False  # if True, Prius is braking

    # preprocess subscribed data
    if array is not None:
        for ii in range(len(array)):
            if not ii%2:  # split data into pts_array and types
                pts_array.append(array[ii])
            else:
                types.append(array[ii])

    x_center = None
    if pts_array is not None:
        x_center_acc = 0  # accumulator for x coordinates of center lanes seen
        x_center_num = 0  # number of center lanes seen
        found_stop = False  # if True: a stop marker was seen
        for ii in range(len(types)):
            if types[ii] == 1:  # types = 1: center lane
                x_center_acc += pts_array[ii]
                x_center_num += 1
            elif types[ii] == 2:  # types = 2: stop marker
                stop_acc += 1  # increase accumulator for consecutive stop markers seen
                found_stop = True  # a stop was found
            elif types[ii] == 3:  # types = 3: center line seen horizontally
                if intersection_center is not None:
                    intersection_center = max(pts_array[ii], intersection_center)  # keep closest intersection center line in case mutliple are detected
                else:
                    intersection_center = pts_array[ii]

        try:  # average all center lines data found, try/except used in case of dividing by zero
            x_center = x_center_acc/x_center_num
        except:
            x_center = None

        if not found_stop:  # if a stop was not found, then zero/reduce all accumulators or prepare to stop
            if (stop_acc >= stop_acc_min or after_stop_count > 0):  # if a stop marker was seen previously for >= the minimum number of times or the car is waiting after having started braking
                # if stop marker was seen for many consecutive times then car was going slow, wait longer to stop to stop with the wheels at the marker
                if delay_current > min(stop_acc - stop_acc_min, 20)-2:
                    is_braking = True  # car is in braking mode
                    throttle = 0
                    brake = 1
                    if after_stop_count == 0:  # first consecutive loop of braking mode: set count during which car is in braking
                        after_stop_count = after_stop_delay
                        in_intersection = True
                    else:  # other loops of braking mode: keep lowering count 
                        after_stop_count -= 1
                        in_intersection = True
                    stop_acc = 0
                else:  # keep delaying braking
                    delay_current += 1
                    is_braking = False
            else:
                # a stop marker was not seen for >= the minimum number of times, car does not brake and stop marker accumulator is zeroed
                # or after_stop_count = 0 and the car can restart
                stop_acc = max(0, stop_acc-1)
                is_braking = False
                delay_current = 0
        
        msg = Control()
        
        # center Prius so that center line is to the left
        if x_center is not None and not is_braking:  # if a center lane is received and the car is not braking, center the car
            if x_center < target_low:  # if car is to the right of the target, steer left
                steer = min(k*abs(x_center-target_low),1)
            elif x_center > target_high:  # if car is to the left of the target, steer right
                steer = -min(k*abs(x_center-target_high),1)
            center_line_acc += 1
            if center_line_acc > 5:
                in_intersection = False
                started_turning = False
        elif x_center is None:
            center_line_acc = 0

        if in_intersection and not is_braking:
            throttle = 0
            if intersection_center is not None:
                # implement logic for deciding whether to turn right or keep straight
                if turn_right:
                    if intersection_center > intersection_y_threshold:
                        steer = -0.9   # right turn
                        #steer = 0.7  # left turn
                        started_turning = True
                        correct_intersection_trigger = False
            if started_turning:
                steer = -0.9   # right turn
                #steer = 0.7  # left turn

        if driving_ctrl == 0 or is_arrived or is_clear_all:
            throttle = 0
            brake = 1
            steer = 0
            iteration = 0

        if is_arrived:
            gear = 1

        # assemble message and publish commands to Prius
        msg.throttle = throttle
        msg.brake = brake
        msg.steer = steer
        msg.shift_gears = gear
        pub.publish(msg)
    iteration += 1
    

if __name__=="__main__":
    rospy.init_node('steering')
    sub_lanes = rospy.Subscriber("/my_lanes/vals",Int32MultiArray,callback)
    sub_obstacles = rospy.Subscriber("/is_clear/front_sonar/all",Byte,is_clear_sonar_callback)
    sub_obstacles_cv = rospy.Subscriber("/is_clear/front_camera/all",Byte,is_clear_camera_callback)
    sub = rospy.Subscriber("/base_pose_ground_truth",Odometry,navigation)
    s = rospy.Service('enable_driving', enable_driving, service_callback)
    s_destination = rospy.Service('destination', destination, service_destination_callback)
    s_landmark = rospy.Service('destination_landmark', destination_landmark, service_landmark_callback)

    # throttle = rospy.get_param("/steering/throttle", 0.02)
    k = rospy.get_param("/steering/k", 0.01)
    stop_acc_min = rospy.get_param("/steering/stop_acc_min", 5)
    after_stop_delay = rospy.get_param("/steering/after_stop_delay", 30)
    target_low = rospy.get_param("/steering/target_low", 280)
    target_high = rospy.get_param("/steering/target_high", 300)
    intersection_y_threshold = rospy.get_param("/steering/intersection_y_threshold", 530)

    # initial state of the prius
    brake = 0
    steer = 0
    gear = 3

    # global variables
    driving_ctrl = 0  # 0 = brake; 1 = self driving
    stop_acc = 0  # accumulation of consecutive times a red stop marker was seen
    after_stop_count = 0  # count since braking on
    delay_current = 0  # count since a red stop marker was not seen anymore
    iteration = 0  # need to activate throttle initially
    in_intersection = False  # True if car is in the intersection
    started_turning = False
    center_line_acc = 0
    #is_clear_all = 0b1111  # from lsb to msb: left to right sonars (1: obstacle is currently detected), camera
    is_clear_all = 0

    x_prev = 0
    y_prev = 0
    # TODO set goal from terminal
    x_goal = None
    y_goal = None
    margin = 7
    eps = 0.002
    turn_right = True
    is_arrived = False
    correct_intersection_trigger = False
    is_braking = False
    cond1 = False
    cond2 = False
    
    pub = rospy.Publisher('prius', Control, queue_size=2)
    rospy.spin()