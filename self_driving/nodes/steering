#!/usr/bin/env python

"""
PARAMETERS:
    /steering/throttle (double): throttle level on the straights
    /steering/k (double): proportional steering gain to align car to have center lane on the left
    /steering/stop_acc_min (int): number of consecutive times a horizontal stop marker has to be identified to be considered
    /steering/after_stop_delay (int): number of loops that the car is still after braking
    /steering/target_low (int): lower target threshold for x-coordinate of the upper end of the center lane
    /steering/target_high (int): upper target threshold for x-coordinate of the upper end of the center lane

PUBLISHES:
    prius (prius_msgs/Control): throttle, braking, steering and gear to control Prius

SUBSCRIBES:
    my_lanes/vals (std_msgs/Int32MultiArray): key points of the lanes and stop markers detected

SERVICES:

"""

import rospy
import numpy as np
from prius_msgs.msg import Control
from std_msgs.msg import Int32MultiArray


def callback(data):
    # callback to execute when receiving lane values
    global throttle, brake, steer, gear, stop_acc, after_stop_count, delay_current
    pts_array = []  # array of points
    types = []  # array of types
    array = data.data  # array of [point, type, point, type, point, type...]

    gear = 2  # put Prius in drive
    brake = 0
    steer = 0
    is_braking = False  # if True, Prius is braking

    # preprocess subscribed data
    if array is not None:
        for ii in range(len(array)):
            if not ii%2:  # split data into pts_array and types
                pts_array.append(array[ii])
            else:
                types.append(array[ii])

    # 
    if pts_array is not None:
        x_center_acc = 0
        x_center_num = 0
        found_stop = False
        for ii in range(len(types)):
            if types[ii] == 1:
                x_center_acc += pts_array[ii]
                x_center_num += 1
            elif types[ii] == 2:
                stop_acc += 1
                found_stop = True
        try:
            x_center = x_center_acc/x_center_num
        except:
            x_center = None
        if not found_stop:
            if (stop_acc > stop_acc_min or after_stop_count > 0):
                if delay_current > stop_acc - stop_acc_min:  # parameter stop_acc threshold  # delay depends somehow on speed
                    is_braking = True
                    throttle = 0
                    brake = 1
                    if after_stop_count == 0:
                        after_stop_count = after_stop_delay  # parameter to tune
                    else:
                        after_stop_count -= 1
                    stop_acc = 0
                else:
                    delay_current += 1
                    is_braking = False
            else:
                stop_acc = 0
                is_braking = False
                delay_current = 0
        
        msg = Control()
        
        if x_center is not None and not is_braking:
            if x_center < target_low:
                steer = min(k*abs(x_center-target_low),1)
            elif x_center > target_high:
                steer = -min(k*abs(x_center-target_high),1)

        msg.throttle = throttle
        msg.brake = brake
        msg.steer = steer
        msg.shift_gears = gear
        pub.publish(msg)
    

if __name__=="__main__":
    rospy.init_node('steering')
    rospy.sub =  rospy.Subscriber("/my_lanes/vals",Int32MultiArray,callback)

    throttle = rospy.get_param("/steering/throttle", 0.02)
    k = rospy.get_param("/steering/k", 0.01)
    stop_acc_min = rospy.get_param("/steering/stop_acc_min", 5)
    after_stop_delay = rospy.get_param("/steering/after_stop_delay", 30)
    target_low = rospy.get_param("/steering/target_low", 280)
    target_high = rospy.get_param("/steering/target_high", 300)

    # initial state of the prius
    brake = 0
    steer = 0
    gear = 3

    # global variables
    stop_acc = 0  # accumulation of consecutive times a red stop marker was seen
    after_stop_count = 0  # count since braking on
    delay_current = 0  # count since a red stop marker was not seen anymore

    pub = rospy.Publisher('prius', Control, queue_size=2)
    rospy.spin()