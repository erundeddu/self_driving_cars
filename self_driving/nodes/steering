#!/usr/bin/env python

"""
PARAMETERS:
    /steering/throttle (double): throttle level on the straights
    /steering/k (double): proportional steering gain to align car to have center lane on the left
    /steering/stop_acc_min (int): number of consecutive times a horizontal stop marker has to be identified to be considered
    /steering/after_stop_delay (int): number of loops that the car is still after braking
    /steering/target_low (int): lower target threshold for x-coordinate of the upper end of the center lane
    /steering/target_high (int): upper target threshold for x-coordinate of the upper end of the center lane

PUBLISHES:
    prius (prius_msgs/Control): throttle, braking, steering and gear to control Prius

SUBSCRIBES:
    my_lanes/vals (std_msgs/Int32MultiArray): key points of the lanes and stop markers detected

SERVICES:
    enable_driving (self_driving/enable_driving): 0 holds the car in brake, 1 drives autonomously
"""

import rospy
import numpy as np
from prius_msgs.msg import Control
from self_driving.srv import enable_driving
from std_msgs.msg import Int32MultiArray

def service_callback(req):
    global driving_ctrl
    driving_ctrl = req.ctrl
    return []

def callback(data):
    # callback to execute when receiving lane values
    global throttle, brake, steer, gear, stop_acc, after_stop_count, delay_current, iteration, in_intersection, started_turning, center_line_acc
    pts_array = []  # array of points
    types = []  # array of types
    array = data.data  # array of [point, type, point, type, point, type...]
    intersection_center = None

    gear = 2  # put Prius in drive
    brake = 0
    steer = 0
    if iteration < 4:  # initial throttle to start car
        throttle = 0.01
    else:
        throttle = 0
        if not iteration % 5:  # brake every 5 iterations to not gain excessive speed
            brake = 0.1
    is_braking = False  # if True, Prius is braking

    # preprocess subscribed data
    if array is not None:
        for ii in range(len(array)):
            if not ii%2:  # split data into pts_array and types
                pts_array.append(array[ii])
            else:
                types.append(array[ii])

    x_center = None
    if pts_array is not None:
        x_center_acc = 0  # accumulator for x coordinates of center lanes seen
        x_center_num = 0  # number of center lanes seen
        found_stop = False  # if True: a stop marker was seen
        for ii in range(len(types)):
            if types[ii] == 1:  # types = 1: center lane
                x_center_acc += pts_array[ii]
                x_center_num += 1
            elif types[ii] == 2:  # types = 2: stop marker
                stop_acc += 1  # increase accumulator for consecutive stop markers seen
                found_stop = True  # a stop was found
            elif types[ii] == 3:  # types = 3: center line seen horizontally
                if intersection_center is not None:
                    intersection_center = max(pts_array[ii], intersection_center)  # keep closest intersection center line in case mutliple are detected
                else:
                    intersection_center = pts_array[ii]

        try:  # average all center lines data found, try/except used in case of dividing by zero
            x_center = x_center_acc/x_center_num
        except:
            x_center = None

        if not found_stop:  # if a stop was not found, then zero all accumulators or prepare to stop
            if (stop_acc >= stop_acc_min or after_stop_count > 0):  # if a stop marker was seen previously for >= the minimum number of times or the car is waiting after having started braking
                # if stop marker was seen for many consecutive times then car was going slow, wait longer to stop to stop with the wheels at the marker
                if delay_current > stop_acc - stop_acc_min:
                    is_braking = True  # car is in braking mode
                    throttle = 0
                    brake = 1
                    if after_stop_count == 0:  # first consecutive loop of braking mode: set count during which car is in braking
                        after_stop_count = after_stop_delay
                        in_intersection = True
                    else:  # other loops of braking mode: keep lowering count 
                        after_stop_count -= 1
                        in_intersection = True
                    stop_acc = 0
                else:  # keep delaying braking
                    delay_current += 1
                    is_braking = False
            else:
                # a stop marker was not seen for >= the minimum number of times, car does not brake and stop marker accumulator is zeroed
                # or after_stop_count = 0 and the car can restart
                stop_acc = 0
                is_braking = False
                delay_current = 0
        
        msg = Control()
        
        # center Prius so that center line is to the left
        if x_center is not None and not is_braking:  # if a center lane is received and the car is not braking, center the car
            if x_center < target_low:  # if car is to the right of the target, steer left
                steer = min(k*abs(x_center-target_low),1)
            elif x_center > target_high:  # if car is to the left of the target, steer right
                steer = -min(k*abs(x_center-target_high),1)
            center_line_acc += 1
            if center_line_acc > 3:
                in_intersection = False
                started_turning = False
        elif x_center is None:
            center_line_acc = 0

        if in_intersection and not is_braking:
            throttle = 0
            if intersection_center is not None:
                if intersection_center > 530:  #TODO # parameter to be calibrated
                    steer = -0.9   # right turn
                    #steer = 0.7  # left turn
                    started_turning = True
            if started_turning:
                steer = -0.9   # right turn
                #steer = 0.7  # left turn

        if driving_ctrl == 0:
            throttle = 0
            brake = 1
            steer = 0
            iteration = 0

        # assemble message and publish commands to Prius
        msg.throttle = throttle
        msg.brake = brake
        msg.steer = steer
        msg.shift_gears = gear
        pub.publish(msg)
    iteration += 1
    

if __name__=="__main__":
    rospy.init_node('steering')
    rospy.sub =  rospy.Subscriber("/my_lanes/vals",Int32MultiArray,callback)
    s = rospy.Service('enable_driving', enable_driving, service_callback)

    # throttle = rospy.get_param("/steering/throttle", 0.02)
    k = rospy.get_param("/steering/k", 0.01)
    stop_acc_min = rospy.get_param("/steering/stop_acc_min", 5)
    after_stop_delay = rospy.get_param("/steering/after_stop_delay", 30)
    target_low = rospy.get_param("/steering/target_low", 280)
    target_high = rospy.get_param("/steering/target_high", 300)

    # initial state of the prius
    brake = 0
    steer = 0
    gear = 3

    # global variables
    driving_ctrl = 0  # 0 = brake; 1 = self driving
    stop_acc = 0  # accumulation of consecutive times a red stop marker was seen
    after_stop_count = 0  # count since braking on
    delay_current = 0  # count since a red stop marker was not seen anymore
    iteration = 0  # need to activate throttle initially
    in_intersection = False  # True if car is in the intersection
    started_turning = False
    center_line_acc = 0

    pub = rospy.Publisher('prius', Control, queue_size=2)
    rospy.spin()