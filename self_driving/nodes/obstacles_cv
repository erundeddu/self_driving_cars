#!/usr/bin/env python

"""
PARAMETERS:
    obstacles_cv/scale_search (double): rescale value for multiscale detection of pedestrians. Lower value gives more granularity but takes longer

PUBLISHES:
    obstacles_cv/image_raw (sensor_msgs/Image): image with bounding boxes for pedestrians
    is_clear/front_camera/all (std_msgs/Byte): if 0 is clear, else a pedestrian is detected

SUBSCRIBES:
    prius/front_camera/image_raw (sensor_msgs/Image): Image from the front camera of the Prius

SERVICES:

"""

import rospy

from sensor_msgs.msg import Image
from std_msgs.msg import Byte
import cv2
import numpy as np
from cv_bridge import CvBridge, CvBridgeError
import time

# this code comes from https://www.geeksforgeeks.org/pedestrian-detection-using-opencv-python/#:~:text=However%2C%20OpenCV%20has%20a%20built,in%20images%20and%20video%20streams.&text=This%20algorithm%20checks%20directly%20surrounding%20pixels%20of%20every%20single%20pixel.


def detect_pedestrians(frame):
    # Detecting all the regions in the Image with a pedestrian
    (regions, _) = hog.detectMultiScale(frame, 
                                        winStride=(4, 4),
                                        padding=(4, 4),
                                        scale=scale_search)
    valid_regions = []
    invalid_regions = []
    for (x, y, w, h) in regions:  # some filtering to avoid false positives at the sides 
        if y+h/2 > 2*frame.shape[0]/5:   # new_width/5 < x+w/2 < 4*new_width/5 and
            valid_regions.append((x, y, w, h))
        else:
            invalid_regions.append((x, y, w, h))  # for visualization only
    return valid_regions, invalid_regions


def track_pedestrians(frame, valid_regions_prev, frame_prev):
    valid_regions_new = list()

    frame_g = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)
    frame_g_prev = cv2.cvtColor(frame_prev, cv2.COLOR_BGR2GRAY)

    valid_regions = list()

    for (x, y, w, h) in valid_regions_prev:       
        #I_prev = frame_g_prev[int(y+0.2*h):int(y+0.8*h), x:(x+w)]
        I_prev = frame_g_prev[int(y):int(y+h), x:(x+w)]
        res = cv2.matchTemplate(frame_g, I_prev, cv2.TM_CCORR_NORMED)
        min_val, max_val, min_loc, max_loc = cv2.minMaxLoc(res)
        ii_max = max_loc[0]
        jj_max = int(max_loc[1] - 0.2*h)
        jj_max = max_loc[1]
        valid_regions.append((ii_max, jj_max, w, h))
    return valid_regions


def callback(data):
    global prev_image, prev_valid_regions, iterations
    try:
        cv_image = bridge.imgmsg_to_cv2(data, "bgr8")
    except CvBridgeError as e:
        print(e)
    # Resizing the Image
    original_width = cv_image.shape[1]
    new_width = min(400, cv_image.shape[1])
    scale = new_width/original_width
    new_height = int(cv_image.shape[0]*scale)
    dim = (new_width, new_height)
    cv_image = cv2.resize(cv_image, dim, interpolation=cv2.INTER_AREA)
    if iterations == 0:
        valid_regions, invalid_regions = detect_pedestrians(cv_image)
    else:
        valid_regions = track_pedestrians(cv_image, prev_valid_regions, prev_image)
        invalid_regions = []
    prev_image = cv_image

    iterations += 1
    if iterations == 30 or len(valid_regions) == 0:
        iterations = 0
    
    for (x, y, w, h) in valid_regions:   
        cv_image = cv2.rectangle(cv_image, (x, y), 
                    (x + w, y + h), 
                    (0, 0, 255), 2)
    for (x, y, w, h) in invalid_regions:   
        cv_image = cv2.rectangle(cv_image, (x, y), 
                    (x + w, y + h), 
                    (255, 0, 0), 2)
    try:
        image_pub.publish(bridge.cv2_to_imgmsg(cv_image, "bgr8"))  # convert to ros image and publish
        prev_valid_regions = valid_regions
    except CvBridgeError as e:
        print(e)
    msg = Byte()
    if len(valid_regions) > 0:
        msg.data = 1
    else:
        msg.data = 0
    pub.publish(msg)


if __name__=="__main__":
    rospy.init_node('obstacles_cv')
    image_pub = rospy.Publisher("/obstacles_cv/image_raw",Image,queue_size=1)
    pub = rospy.Publisher("/is_clear/front_camera/all",Byte,queue_size=1)
    bridge = CvBridge()  # used to convert ROS images to opencv images and vice versa
    image_sub = rospy.Subscriber("/prius/front_camera/image_raw",Image,callback)

    scale_search = rospy.get_param("/obstacles_cv/scale_search", 1.05)

    hog = cv2.HOGDescriptor()
    hog.setSVMDetector(cv2.HOGDescriptor_getDefaultPeopleDetector())    
    prev_image = None  # stores previous frame
    prev_valid_regions = None  # stores valid pedestrian regions found in previous frame
    iterations = 0  # counter to switch between detection and tracking

    rospy.spin()