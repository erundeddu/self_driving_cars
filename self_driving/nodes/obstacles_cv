#!/usr/bin/env python

"""
PARAMETERS:
    obstacles_cv/scale_search (double): rescale value for multiscale detection of pedestrians. Lower value gives more granularity but takes longer

PUBLISHES:
    obstacles_cv/image_raw (sensor_msgs/Image): image with bounding boxes for pedestrians
    is_clear/front_camera/all (std_msgs/Byte): if 0 is clear, else a pedestrian is detected

SUBSCRIBES:
    prius/front_camera/image_raw (sensor_msgs/Image): Image from the front camera of the Prius

SERVICES:

"""

import rospy

from sensor_msgs.msg import Image
from std_msgs.msg import Byte
import cv2
import numpy as np
from cv_bridge import CvBridge, CvBridgeError

# this code comes from https://www.geeksforgeeks.org/pedestrian-detection-using-opencv-python/#:~:text=However%2C%20OpenCV%20has%20a%20built,in%20images%20and%20video%20streams.&text=This%20algorithm%20checks%20directly%20surrounding%20pixels%20of%20every%20single%20pixel.

def callback(data):
    try:
        cv_image = bridge.imgmsg_to_cv2(data, "bgr8")
    except CvBridgeError as e:
        print(e)
    # Resizing the Image
    original_width = cv_image.shape[1]
    new_width = min(400, cv_image.shape[1])
    scale = new_width/original_width
    new_height = int(cv_image.shape[0]*scale)
    dim = (new_width, new_height)
    cv_image = cv2.resize(cv_image, dim, interpolation=cv2.INTER_AREA)
    # Detecting all the regions in the Image with a pedestrian
    (regions, _) = hog.detectMultiScale(cv_image, 
                                        winStride=(4, 4),
                                        padding=(4, 4),
                                        scale=scale_search)
    valid_regions = []
    invalid_regions = []
    new_height = cv_image.shape[0]
    for (x, y, w, h) in regions:  # some filtering to avoid false positives at the sides 
        if y+h/2 > 2*new_height/5:   # new_width/5 < x+w/2 < 4*new_width/5 and
            valid_regions.append((x, y, w, h))
        else:
            invalid_regions.append((x, y, w, h))

    for (x, y, w, h) in valid_regions:   
        cv_image = cv2.rectangle(cv_image, (x, y), 
                    (x + w, y + h), 
                    (0, 0, 255), 2)
    for (x, y, w, h) in invalid_regions:   
        cv_image = cv2.rectangle(cv_image, (x, y), 
                    (x + w, y + h), 
                    (255, 0, 0), 2)
    try:
        image_pub.publish(bridge.cv2_to_imgmsg(cv_image, "bgr8"))  # convert to ros image and publish
    except CvBridgeError as e:
        print(e)
    msg = Byte()
    if len(valid_regions) > 0:
        msg.data = 1
    else:
        msg.data = 0
    pub.publish(msg)


if __name__=="__main__":
    rospy.init_node('obstacles_cv')
    image_pub = rospy.Publisher("/obstacles_cv/image_raw",Image,queue_size=2)
    pub = rospy.Publisher("/is_clear/front_camera/all",Byte,queue_size=2)
    bridge = CvBridge()  # used to convert ROS images to opencv images and vice versa
    image_sub = rospy.Subscriber("/prius/front_camera/image_raw",Image,callback)

    scale_search = rospy.get_param("/obstacles_cv/scale_search", 1.05)

    hog = cv2.HOGDescriptor()
    hog.setSVMDetector(cv2.HOGDescriptor_getDefaultPeopleDetector())    

    rospy.spin()