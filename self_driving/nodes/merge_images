#!/usr/bin/env python

"""
PARAMETERS:

PUBLISHES:
    merged/image_raw (sensor_msgs/Image): image with bounding boxes for pedestrians and detected lines

SUBSCRIBES:
    obstacles_cv/image_raw (sensor_msgs/Image): image with bounding boxes for pedestrians
    my_lanes/image_raw (sensor_msgs/Image): Image showing the lanes and stop markers recognized

SERVICES:

"""


## NOT READY

import rospy

from sensor_msgs.msg import Image
import cv2
import numpy as np
from cv_bridge import CvBridge, CvBridgeError


def callback_lane(data):
    global lane_image, obstacles_image
    try:
        lane_image = bridge.imgmsg_to_cv2(data, "bgr8")
    except CvBridgeError as e:
        print(e)
    combined_image = cv2.addWeighted(cv_image, 0.8, line_image, 1, 1)
    try:
        image_pub.publish(bridge.cv2_to_imgmsg(cv_image, "bgr8"))  # convert to ros image and publish
    except CvBridgeError as e:
        print(e)

def callback_obstacles(data):
    global lane_image, obstacles_image
    try:
        obstacles_image = bridge.imgmsg_to_cv2(data, "bgr8")
    except CvBridgeError as e:
        print(e)
    combined_image = cv2.addWeighted(cv_image, 0.8, line_image, 1, 1)
    try:
        image_pub.publish(bridge.cv2_to_imgmsg(cv_image, "bgr8"))  # convert to ros image and publish
    except CvBridgeError as e:
        print(e)

def publish_combined_image(img1, img2):
    if img1 is not None and img2 is not None:
        combined_image = cv2.addWeighted(lane_image, )


if __name__=="__main__":
    rospy.init_node('merge_images')
    image_pub = rospy.Publisher("/merged/image_raw",Image,queue_size=2)
    bridge = CvBridge()  # used to convert ROS images to opencv images and vice versa
    lane_image_sub = rospy.Subscriber("/my_lanes/image_raw",Image,callback_lane)
    obstacles_image_sub = rospy.Subscriber('/obstacles/image_raw',Image,callback_obstacles)

    lane_image = None
    obstacles_image = None

    rospy.spin()