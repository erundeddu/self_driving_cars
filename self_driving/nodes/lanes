#!/usr/bin/env python

"""
PARAMETERS:
    lanes/hough_threshold (int): minimum voting threshold in Hough space to recognize a line
    lanes/min_line_length (int): minimum length of a line to be reported
    lanes/max_line_gap (int): gap between lines to be considered separate
    lanes/lane_rect (int): half the length in the direction perpendicular to the recognized line to draw a ROI for color detection
    lanes/min_red_threshold (int): minimum threshold of presence of red pixels to recognize a stop marker
    lanes/min_yellow_threshold (int): minimum threshold of presence of yellow pixels to recognize a center line
    lanes/min_hue_red (int): minimum hue value (before 0) for red
    lanes/max_hue_red (int): maximum hue value (after 0) for red
    lanes/min_hue_yellow (int): minimum hue value for yellow
    lanes/max_hue_yellow (int): maximum hue value for yellow

PUBLISHES:
    my_lanes/image_raw (sensor_msgs/Image): Image showing the lanes and stop markers recognized
    my_lanes/x_vals (std_msgs/Int32MultiArray): key points of the lanes and stop markers detected

SUBSCRIBES:
    prius/front_camera/image_raw (sensor_msgs/Image): Image from the front camera of the Prius

SERVICES:

"""

import rospy
import cv2
import numpy as np
from sensor_msgs.msg import Image
from std_msgs.msg import Int32MultiArray
from cv_bridge import CvBridge, CvBridgeError

def make_points(image, line):
    slope, intercept = line
    if abs(slope) > 0.2:
        y1 = int(image.shape[0])  # bottom of the image
        y2 = int(y1*3/5)         # slightly lower than the middle
        x1 = int((y1 - intercept)/slope)
        x2 = int((y2 - intercept)/slope)
    else:
        x1 = 0
        x2 = image.shape[1]
        y1 = int(x1*slope + intercept)
        y2 = int(x2*slope + intercept)
    return [[x1, y1, x2, y2]]

def average_slope_intercept(image, lines):
    candidate_stop_lines = []
    filtered_lines = []
    for line in lines:
        for x1, y1, x2, y2 in line:
            fit = np.polyfit((x1,x2), (y1,y2), 1)
            slope = fit[0]
            intercept = fit[1]
            if 0.7 < abs(slope):
                filtered_lines.append((slope, intercept))
            elif abs(slope) < 0.2:
                candidate_stop_lines.append((slope, intercept))
    avg_lines = []
    d_slope = 15*3.14159/180
    d_inter = 100
    d_x = 10
    for line in filtered_lines:
        did_append = False
        for sub_list in avg_lines:
            for compare_line in sub_list:
                y = int((image.shape[0])*3/5)         # slightly lower than the middle
                slope_cp = compare_line[0]
                intercept_cp = compare_line[1]
                slope_ln = line[0]
                intercept_ln = line[1]
                x_cp = int((y - intercept_cp)/slope_cp)
                x_ln = int((y - intercept_ln)/slope_ln)
                if abs(x_cp - x_ln) > d_x:
                    break
            else:
                sub_list.append(line)
                did_append = True
        if not did_append:
            avg_lines.append([line])
    
    avg_stop_lines = []
    d_y = 30
    for line in candidate_stop_lines:
        did_append = False
        for sub_list in avg_stop_lines:
            for compare_line in sub_list:
                x1 = 0         
                x2 = image.shape[1]
                slope_cp = compare_line[0]
                intercept_cp = compare_line[1]
                slope_ln = line[0]
                intercept_ln = line[1]
                y_cp_1 = int(intercept_cp + slope_cp*x1)
                y_cp_2 = int(intercept_cp + slope_cp*x2)
                y_ln_1 = int(intercept_ln + slope_cp*x1)
                y_ln_2 = int(intercept_ln + slope_cp*x2)
                if abs(y_cp_1 - y_ln_1) > d_y or abs(y_cp_2 - y_ln_2) > d_y:
                    break
            else:
                sub_list.append(line)
                did_append = True
        if not did_append:
            avg_stop_lines.append([line])

    avg_lines_out = []
    stop_lines_out = []
    for sub_list in avg_lines:
        fit_average = np.average(sub_list, axis=0)
        line = make_points(image, fit_average)
        avg_lines_out.append(line)
    for sub_list in avg_stop_lines:
        fit_average = np.average(sub_list, axis=0)
        line = make_points(image, fit_average)
        stop_lines_out.append(line)
    return avg_lines_out, stop_lines_out

def canny(img):
    gray = cv2.cvtColor(img, cv2.COLOR_RGB2GRAY)
    kernel = 5
    blur = cv2.GaussianBlur(img,(kernel, kernel),2)
    canny = cv2.Canny(blur, 50, 150)
    return canny

def display_lines(img,lines,types):
    line_image = np.zeros_like(img)
    count = 0
    if lines is not None:
        for line in lines:
            for x1, y1, x2, y2 in line:
                if types[count] == 1:
                    cv2.line(line_image,(x1,y1),(x2,y2),(0,255,255),10)
                elif types[count] == 2:
                    cv2.line(line_image,(x1,y1),(x2,y2),(0,0,255),10)
                else:
                    cv2.line(line_image,(x1,y1),(x2,y2),(255,0,0),10)
            count += 1
    return line_image

def region_of_interest(canny):
    height = canny.shape[0]
    width = canny.shape[1]
    mask = np.zeros_like(canny)

    trapz = np.array([[
    (100, 109*height//160),
    (200, 11*height//20),
    (600, 11 * height//20),
    (700, 109*height//160),]], np.int32)

    trapz = np.array([[
    (0, 109*height//160),
    (0, 9*height//20),
    (800, 9* height//20),
    (800, 109*height//160),]], np.int32)

    cv2.fillPoly(mask, trapz, 255)
    masked_image = cv2.bitwise_and(canny, mask)
    return masked_image


class image_converter:

  def __init__(self):
    self.image_pub = rospy.Publisher("/my_lanes/image_raw",Image,queue_size=10)
    self.bridge = CvBridge()
    self.image_sub = rospy.Subscriber("/prius/front_camera/image_raw",Image,self.callback)
    self.lanes_pub = rospy.Publisher("/my_lanes/x_vals",Int32MultiArray,queue_size=10)

  def callback(self,data):
    try:
      cv_image = self.bridge.imgmsg_to_cv2(data, "bgr8")
    except CvBridgeError as e:
      print(e)

    (rows,cols,channels) = cv_image.shape
    canny_image = canny(cv_image)
    cropped_canny = region_of_interest(canny_image)
    lines = cv2.HoughLinesP(cropped_canny, 2, np.pi/180, hough_threshold, np.array([]), minLineLength=min_line_length,maxLineGap=max_line_gap)
    if lines is not None:
        averaged_lines, stops = average_slope_intercept(cv_image, lines)
        types = []
        for ln in averaged_lines:
            height = cv_image.shape[0]
            width = cv_image.shape[1]
            mask = np.zeros_like(cv_image)
            pts = ln[0]
            d_rect = lane_rect
            trapz = np.array([[[
                (pts[0]-d_rect, pts[1]),
                (pts[2]-d_rect, pts[3]),
                (pts[2]+d_rect, pts[3]),
                (pts[0]+d_rect, pts[1]),]]], np.int32)
            cv2.fillPoly(mask, trapz, [255,255,255])
            masked_image = cv2.bitwise_and(cv_image, mask)
            hsv_frame = cv2.cvtColor(masked_image, cv2.COLOR_BGR2HSV)
            low_yellow = np.array([min_hue_yellow, 150, 64])
            high_yellow = np.array([max_hue_yellow, 255, 255])
            yellow_mask = cv2.inRange(hsv_frame, low_yellow, high_yellow)

            yellow = cv2.bitwise_and(cv_image, cv_image, mask=yellow_mask)
            num_yellow = np.sum(yellow_mask)
            if num_yellow > min_yellow_threshold:
                types.append(1)
            else:
                types.append(0)

        for ln in stops:
            height = cv_image.shape[0]
            width = cv_image.shape[1]
            mask = np.zeros_like(cv_image)
            pts = ln[0]
            d_rect = lane_rect
            trapz = np.array([[[
                (pts[0], max(pts[1]-d_rect,0)),
                (pts[2], max(pts[1]-d_rect,0)),
                (pts[2], min(pts[3]+d_rect,height)),
                (pts[0], min(pts[3]+d_rect,height)),]]], np.int32)
            cv2.fillPoly(mask, trapz, [255,255,255])
            masked_image = cv2.bitwise_and(cv_image, mask)
            hsv_frame = cv2.cvtColor(masked_image, cv2.COLOR_BGR2HSV)
            low_red_1 = np.array([min_hue_red,100,60])
            high_red_1 = np.array([180,255,255])
            red_mask_1 = cv2.inRange(hsv_frame, low_red_1, high_red_1)
            low_red_2 = np.array([0,100,60])
            high_red_2 = np.array([max_hue_red,255,255])
            red_mask_2 = cv2.inRange(hsv_frame, low_red_2, high_red_2)

            red_mask = red_mask_1 | red_mask_2

            red = cv2.bitwise_and(cv_image, cv_image, mask=red_mask)
            num_red = np.sum(red_mask)
            if num_red > min_red_threshold:
                types.append(2)
                averaged_lines.append(ln)

        line_image = display_lines(cv_image, averaged_lines, types)
        combo_image = cv2.addWeighted(cv_image, 0.8, line_image, 1, 1)

        lane_data = Int32MultiArray()
        lane_data_array = []
        for ii in range(len(types)):
            if types[ii] != 2:
                lane_data_array.append(averaged_lines[ii][0][2])
            else:
                lane_data_array.append(averaged_lines[ii][0][1])
            lane_data_array.append(types[ii])
        lane_data.data = lane_data_array
        self.lanes_pub.publish(lane_data)
    else:
        combo_image = cv_image
    try:
      self.image_pub.publish(self.bridge.cv2_to_imgmsg(combo_image, "bgr8"))  #bgr8
    except CvBridgeError as e:
      print(e)


if __name__=="__main__":
    rospy.init_node('lanes')

    hough_threshold = rospy.get_param("lanes/hough_threshold", 100)
    min_line_length = rospy.get_param("lanes/min_line_length", 40)
    max_line_gap = rospy.get_param("lanes/max_line_gap", 5)
    lane_rect = rospy.get_param("lanes/lane_rect", 8)
    min_red_threshold = rospy.get_param("lanes/min_red_threshold", 300000)
    min_yellow_threshold = rospy.get_param("lanes/min_yellow_threshold", 60000)
    min_hue_red = rospy.get_param("lanes/min_hue_red", 170)
    max_hue_red = rospy.get_param("lanes/max_hue_red", 10)
    min_hue_yellow = rospy.get_param("lanes/min_hue_yellow", 25)
    max_hue_yellow = rospy.get_param("lanes/max_hue_yellow", 40)

    ic = image_converter()
    rospy.spin()